

= Making Clojure Even Sweeter

Leiningen coordinates:   

image:http://clojars.org/tupelo/latest-version.svg[ http://clojars.org/tupelo ]

=== http://cloojure.github.io/doc/tupelo[The Tupelo-Datomic API Docs] 
are posted on GitHub Pages.

== Tupelo Overview

Have you ever wanted to do something simple but clojure.core doesn't support it? Or, maybe
you are wishing for an enhanced version of a standard function. The goal of Tupelo is to
add support for these convenience features, so that you have a simple way of using either
the enhanced version or the original version.

== Tupelo Organization

The functionality of the Tupelo library is divided into a number of
namespaces, each with a single area of focus. These are:

==== Tupelo Core - A library of helper functions for core Clojure. 

Please see the xref:tupelo-core-overview[tupelo.core] docs further below.

==== Tupelo Datomic - A library of helper functions for Datomic. 

Please see the link:src/tupelo/datomic.adoc[tupelo.datomic] docs.

==== Tupelo CSV - Functions for using CSV (Comma Separate Value) files

The standard link:http://github.com/davidsantiago/clojure-csv[clojure-csv library] has well-tested
and useful functions for parsing CSV (Comma Separated Value) text data, but it does not offer all of
the convenience one may wish. Tupelo CSV emphasizes the idomatic Clojure usage of data, using
sequences and maps. Please see the link:src/tupelo/csv.adoc[tupelo.csv] docs.

==== Tupelo Parse - Functions to ease text parsing 

Please see the link:http://cloojure.github.io/doc/tupelo/tupelo.parse.html[tupelo.parse] docs.

==== Tupelo Misc - A grab bag of functions that don't fit anywhere else (yet!)

Please see the link:http://cloojure.github.io/doc/tupelo/tupelo.misc.html[tupelo.misc] docs.

==== tupelo.base64 - Convert to/from base64 encoding. 

Please see the link:http://cloojure.github.io/doc/tupelo/tupelo.base64.html[tupelo.base64] docs.

==== tupelo.base64url - Convert to/from base64url encoding. 

Please see the link:http://cloojure.github.io/doc/tupelo/tupelo.base64url.html[tupelo.base64url] docs.

==== Tupelo Y64 - Convert to/from the URL-safe Y64 encoding (Yahoo YUI library).

Please see the link:http://cloojure.github.io/doc/tupelo/tupelo.y64.html[tupelo.y64] docs.


[[tupelo-core-overview]]


== Tupelo Core Overview

Have you ever wanted to do something simple but `clojure.core` doesn't support it? Or, maybe
you are wishing for an enhanced version of a standard function. The goal of `tupelo.core` is to
add support for these convenience features, so that you have a simple way of using either
the enhanced version or the original version.

The goal in using `tupelo.core` is that you can just plop it into any namespace without
having to worry about any conflicts with `clojure.core` functionality. So, both the core functions
and the added/enhanced functions are both available for use at all times. As such, we use
normally use `:refer :all` for `tupelo.core` in our namespaces:

[source,clojure]
----
(ns my.proj
  (:require [tupelo.core    :refer :all]
            [tupelo.datomic :as td]
            ... ))
----

=== tupelo.core - Basic functions

=== Expression Debugging

Have you ever been debugging some code and had trouble printing out intermediate
values?  For example:

[source,clojure]
----
(-> 1
    (inc)       ; want to print value in pipeline after "(inc)" expression
    (* 2))
4
----
Suppose you want to display the value after the `(inc)` function. You can't just insert a
`(println ...)` because the return value of `nil` will break the pipeline structure. Instead,
just use `spy`:

[source,clojure]
----
(-> 1
    (inc)
    (spy)       ; print value at this location in pipeline
    (* 2))
;; spy => 2     ; output from spy
4               ; return value from the threading pipeline
----
This tool is named `spy` since it can display values from inside any threading form without
affecting the result of the expression.  In this case, `spy` printed the value `2` resulting from
the `(inc)` expression. Then, the value `2` continued to flow through the following expressions in
the pipeline so that the return value of the expression is unchanged.  

You can add in a string message to label each `spy` output:
[source,clojure]
----
(-> 1
    (inc)
    (spy :msg "after inc")      ; add a custom message
    (* 2))
;; after inc => 2               ; spy output is labelled with message
4                               ; return value is unchanged
----
Note that `spy` works equally well inside either a "thread-first" or a "thread-last" form
(e.g. using `\->` or `\->>`), without requiring any changes.

[source,clojure]
----
(->> 1
    (inc)
    (spy :msg "after inc")      ; spy works equally with both  ->  and  ->>  forms
    (* 2))
;; after inc => 2
4
----

How does `spy` accomplish this trick? The answer is that the keyword `:msg` is required just before
the message string, and it is this which allows `spy` to detect whether it is in a thread-first or
thread-last form, and thus produce the correct output. As a bonus for debugging, the value is output
using (pr-str ...) so that numbers and strings are unambiguous in the output:

[source,clojure]
----
(-> 30 
    (+ 4) 
    (spy :msg "dbg")
    (* 10))
;; dbg => 34            ; integer result = 34
340

(-> "3" 
    (str "4")
    (spy :msg "dbg")
    (str "0"))
;; dbg => "34"          ; string result = "34"
"340"
----

Sometimes you may prefer to print out the literal expression instead of a
message. In this case, just use `spyx` (short for "spy expression") :
[source,clojure]
----
(as-> 1 x
      (spyx (inc x))
      (* 2 x))
;; (inc x) => 2         ; the expression is used as the label
4
----
In other instances, you may wish to use `spyxx` to display the expression, its 
type, and its value:
[source,clojure]
----
(defn mystery-fn [] (into (sorted-map) {:b 2 :a 1}))
(spyxx (mystery-fn))
;; (mystery-fn) => clojure.lang.PersistentTreeMap->{:a 1, :b 2}
----
Non-pure functions (i.e. those with side-effects) are safe to use with `spy`.
Any expression supplied to spy will be evaluated only once.

To be precise, the function signatures for `spy` are:
[source,clojure]
----
(spy <expr>)                ; print value of <expr> w/o custom message string
(spy <expr> :msg msg-str)   ; works with ->   (the ":msg" keyword is required)
(spy :msg msg-str <expr>)   ; works with ->>  (the ":msg" keyword is required)
(spyx  <expr>)              ; prints <expr> and its value
(spyxx <expr>)              ; prints <expr>, its type, and its value
----

=== Literate Threading Macro

We all love to use the threading macros `\->` and `\->>` for certain tasks, but they only work if
all of the forms should be threaded into the first or last argument.

The built-in threading macro `as\->` can avoid this requirement, but the order of the first
expression and the placeholder symbol is arguably backwards from what users would expect. Also,
there is often no obvious name to use for the placeholder symbol.  Re-using a good idea from Groovy,
we simply use the symbol `it` as the placeholder symbol in each expression to represent the value of
the previous result.

[source,clojure]
----
(it-> 1
      (inc it)                                  ; thread-first or thread-last
      (+ it 3)                                  ; thread-first
      (/ 10 it)                                 ; thread-last
      (str "We need to order " it " items." )   ; middle of 3 arguments
;=> "We need to order 2 items." )
----

=== Map Value Lookup

Maps are convenient, especially when keywords are used as functions to look up a value in
a map.  Unfortunately, attempting to look up a non-existent keyword in a map will return
`nil`.  While sometimes convenient, this means that a simple typo in the keyword name will
silently return corrupted data (i.e. `nil`) instead of the desired value.

Instead, use the function `grab` for keyword/map lookup:
[source,clojure]
----
(grab k m)
  "A fail-fast version of keyword/map lookup.  When invoked as (grab :the-key the-map), 
   returns the value associated with :the-key as for (clojure.core/get the-map :the-key).  
   Throws an Exception if :the-key is not present in the-map."

(def sidekicks {:batman "robin" :clark "lois"})
(grab :batman sidekicks)
;=> "robin"

(grab :spiderman m)
;=> IllegalArgumentException Key not present in map:
map : {:batman "robin", :clark "lois"}
keys: [:spiderman]
----
The function `grab` should also be used in place of `clojure.core/get`. Simply reverse the order of arguments to
match the "keyword-first, map-second" convention.

For looking up values in nested maps, the function `fetch-in` replaces `clojure.core/get-in`:
[source,clojure]
----
(fetch-in m ks)
  "A fail-fast version of clojure.core/get-in. When invoked as (fetch-in the-map keys-vec), 
   returns the value associated with keys-vec as for (clojure.core/get-in the-map keys-vec).  
   Throws an Exception if the path keys-vec is not present in the-map."

(def mm {:a 1 :b {:c 3}})
(fetch-in mm [:b :c])
3
(fetch-in mm [:b :z])
;=> IllegalArgumentException Key seq not present in map:
;=>   map : {:b {:c 3}, :a 1}
;=>   keys: [:b :z]
----

=== Map Dissociation

Clojure has functions `assoc` & `assoc-in`, `update` & `update-in`, and `dissoc`. However, there
is no function `dissoc-in`.  The function `dissoc-in` provides the desired functionality:

[source,clojure]
----
(dissoc-in the-map keys-vec)
  "A sane version of dissoc-in that will not delete intermediate keys. 
   When invoked as (dissoc-in the-map [:k1 :k2 :k3... :kZ]), acts like 
   (clojure.core/update-in the-map [:k1 :k2 :k3...] dissoc :kZ). That is, only 
   the map entry containing the last key :kZ is removed, and all map entries 
   higher than kZ in the hierarchy are unaffected."
----

The unit test shows the functions in action:

[source,clojure]
----
(let [mm {:a { :b { :c "c" }}} ]
  (is (= (dissoc-in mm []         ) mm ))
  (is (= (dissoc-in mm [:a      ] ) {} ))
  (is (= (dissoc-in mm [:a :b   ] ) {:a {}} ))
  (is (= (dissoc-in mm [:a :b :c] ) {:a { :b {}}} ))
  (is (= (dissoc-in mm [:a :x :y] ) {:a { :b { :c "c" }
                                             :x nil }} )))
----

Note that if non-existant keys are included in `keys-vec`, any missing map
layers will be constructed as necessary, which is consistant with the behavior
of both `clojure.core/assoc-in` and `clojure.core/update-in` (note that `nil` is
the value of the final map entry, not the empty map `{}` as for the other examples). 

Note that only the map entry corresponding to the last key `kZ` is cleared. This
differs from the `dissoc-in` function in the old clojure-contrib library whichjj
had the unpredictable behavior of recursively (& silently) deleting all keys in
`keys-vec` corresponding to empty maps.

=== Gluing Together Like Collections

The `concat` function can sometimes have rather surprising results:
[source,clojure]
----
(is (= (concat {:a 1} {:b 2} {:c 3} )
             [ [:a 1] [:b 2] [:c 3] ] ))
----
In this example, the user probably meant to merge the 3 maps into one. Instead, the three
maps were mysteriously converted into length-2 vectors, which were then nested inside another
sequence.

The `conj` function can also surprise the user:
[source,clojure]
----
(is (= (conj [1 2] [3 4])
             [1 2  [3 4] ] ))
----

Here the user probably wanted to get `[1 2 3 4]` back, but instead got a nested
vector by mistake.

Instead of having to wonder if the items to be combined will be merged, nested, or
converted into another data type, we provide the `glue` function to *always*
combine like collections together into a result collection of the same type:

[source,clojure]
----
; Glues together like collections:
(is (= (glue [ 1 2] [ 3 4] [ 5 6] )     [ 1 2 3 4 5 6 ]  ))
(is (= (glue {:a 1} {:b 2} {:c 3} )     {:a 1 :c 3 :b 2} ))
(is (= (glue #{1 2} #{3 4} #{6 5} )    #{ 1 2 6 5 3 4 }  ))

; If you want to convert to a sorted set or map, just put an empty one first:
(is (= (glue (sorted-map) {:a 1} {:b 2} {:c 3})   {:a 1 :b 2 :c 3} ))
(is (= (glue (sorted-set) #{1 2} #{3 4} #{6 5})  #{ 1 2 3 4 5 6  } ))
----

An `Exception` will be thrown if the collections to be 'glued' are not all of
the same type. The allowable input types are:

  - mixed lists & vectors
  - all maps (sorted or not)
  - all sets (sorted or not)

=== Convenience in Testing Seq's

These functions aren't in clojure.core, but people keep writing into the mailing list
wondering where they are. Well, now they are available:

----
(any? pred coll)
  For any predicate & collection, returns true if (pred x) is 
  logical true for any x in coll; otherwise returns false. Like
  clojure.core/some, but returns only true or false.

(not-empty? coll)
  For any collection, returns true if coll contains any items; 
  otherwise returns false. Equivalent to (not (empty? coll)).
----
The unit test shows these functions in action
[source,clojure]
----
(is (= true   (any? odd? [1 2 3] ) ))
(is (= false  (any? odd? [2 4 6] ) ))
(is (= false  (any? odd? []      ) ))

(is (= (map not-empty? ["1"   [1]   '(1)  {:1 1}  #{1} ] )
                       [true  true  true  true    true ]  ))
(is (= (map not-empty? [""     []      '()    {}     #{}    nil   ] )
                       [false  false   false  false  false  false ] ))
----

=== Focus on Vectors

Clojure's seq abstraction (and lazy seq's) is very useful, but sometimes you just want
everything to stay in a nice, eager, random-access vector. Here is an easy way to build up
a vector result:

[source,clojure]
----
(conjv base-coll value)
(conjv base-coll value & values)
  Given base-coll and and one or more values, converts base-coll to a vector and then appends the values.
  The result is always returned as a vector.

=> (conjv '(1 2) 3)
[1 2 3]
=> (conjv [1 2] 3 4 5 6)
[1 2 3 4 5 6]
----

Similarly, we may wish to use an eager (non-lazy) version of `for` which always returns results
in a vector:

[source,clojure]
----
(is (= (forv [x (range 4)] (* x x))
       [0 1 4 9] ))
----

=== Validating Intermediate Results

Within a processing chain, it is often desirable to verify that an intermediate value is
within an expected range or of an expected type. The built-in `assert` function cannot be
used for this purpose since it returns `nil`, and the Prismatic Schema `validate` can only
perform a limited amount of type testing.  The `(validate ...)` function performs
arbitrary validation, throwing an exception if a non-truthy result is returned:

[source,clojure]
---- 
(validate tstfn tstval)
  Used to validate intermediate results. Returns tstval if the result of 
  (tstfn tstval) is truthy.  Otherwise, throws IllegalStateException.

(is (= 3    (validate pos?        3    )))
(is (= 3.14 (validate number?     3.14 )))
(is (= 3.14 (validate #(< 3 % 4)  3.14 )))
---- 

=== Map Entries (Key-Value pairs)

Sometimes you want to extract the keys & values from a map for manipulation or extension
before building up another map (especially useful for manipulating default function args).
Here is very handy function for that:

[source,clojure]
----
(keyvals m)
  For any map m, returns the keys & values of m as a vector, 
  suitable for reconstructing via (apply hash-map (keyvals m)).

(keyvals {:a 1 :b 2})
;=> [:b 2 :a 1]
(apply hash-map (keyvals {:a 1 :b 2}))
;=> {:b 2, :a 1}
----

=== Default Value in Case of Exception

Sometimes you know an operation may result in an Exception, and you would like to have the
Exception converted into a default value.  That is when you need:

[source,clojure]
----
(with-exception-default default-val & body)
  Evaluates body & returns its result.  In the event of an exception the
  specified default value is returned instead of the exception."

(with-exception-default 0
  (Long/parseLong "12xy3"))
;=> 0
----


This feature is put to good use in link:http://cloojure.github.io/doc/tupelo/tupelo.parse.html[tupelo.parse], 
where you will find functions that work like this:

[source,clojure]
----
(parse-long "123")                  ; throws if parse error
;=> 123
(parse-long "1xy23" :default 666)   ; returns default val if parse error
;=> 666
----

=== Floating Point Number Comparison

Everyone knows that you shouldn't compare floating-point numbers (e.g. float,
double, etc) for equality since roundoff errors can prevent a precise match
between logically equivalent results.  However, it has always been awkward to
regenerate "approx-equals" code by hand every time new project requires it.
Here we have a simple function that compares two floating-point values (cast to
double) for relative equality by specifying either the number of significant
digits that must match or the maximum error tolerance allowed:

[source,clojure]
----
(rel= val1 val2 & opts)
  Returns true if 2 double-precision numbers are relatively equal, else false.
  Relative equality is specified as either (1) the N most significant digits are
  equal, or (2) the absolute difference is less than a tolerance value.  Input
  values are coerced to double before comparison.  
----

An extract from the unit tests illustrates the use of `rel=`

[source,clojure]
----
(is      (rel= 123450000 123456789 :digits 4 ))
(is (not (rel= 123450000 123456789 :digits 6 )))

(is      (rel= 1 1.001 :tol 0.01 ))
(is (not (rel= 1 1.001 :tol 0.0001 )))
----

=== String Operations

Suppose you have a bunch of nested results and you just want to convert everything into a single
string. In that case, `strcat` is for you:

[source,clojure]
----
(is (= (strcat "I " [ \h \a \v [\e \space (byte-array [97]) 
                      [ 32 "complicated" (Math/pow 2 5) '( "str" "ing") ]]] )
       "I have a complicated string" ))
----


Sometimes, you may wish to clip a string to a maximum length for ease of display. In that case, use `clip-str`:

[source,clojure]
----
(is (= "abc"             (clip-str  3 "abcdefg")))
(is (= "{:a 1, :"        (clip-str  8 (sorted-map :a 1 :b 2) )))
(is (= "{:a 1, :b 2}"    (clip-str 99 (sorted-map :a 1 :b 2) )))
----

Notice that clip-str will accept any argument type (map, sequence, etc), and convert it into a
string for you. Also, it will work correctly even if the clip-length is an upper bound; shorter
strings are returned unchanged.

=== Keeping & Dropping Elements of a Sequence

When processing sequences of data, we often need to extract a sequence of desired data, or,
conversely, remove all of the undesired elements. 
Have you ever been left wondering which of these two forms is correct?

[source,clojure]
----
(let [result (filter even? (range 10)) ]
  (assert (or (= result [ 1 3 5 7 9 ] )     ; is it "remove bad" (falsey) 
              (= result [ 0 2 4 6 8 ] ))))  ; or    "keep good"  (truthy) ???
----

I normally think of filters as removing bad things.  Air filters remove dust.  Coffee filters keep
coffee grounds out of my cup. A noise filter in my stereo removes contaminating frequencies from my
music. However, `filter` in Clojure is written in reverse, so that it *_keeps_* items identified by
the predicate. Wouldn't be nicer (and much less ambiguous) if you could just write the following?

[source,clojure]
----
(is (= [0 2 4 6 8]  (keep-if even? (range 10))
                    (drop-if odd?  (range 10))))
----

It seems to me that `keep-if` and `drop-if` are much more natural names and remove ambiguity from
the code.  Of course, these are just thin (& lazy) wrappers around the built-in `clojure.core`
functions, but they are much less ambiguous. I think they make the code easier to read and the
intent more obvious.

=== Extracting *_Only_* Values

The pervasive use of seq's in Clojure means that scalar values often appear wrapped in a vector or
some other sequence type.  As a result, one often sees code like `(first some-var)` and it is not
always clear that the code is simply "unwrapping" a scalar value, since there could well be
remaining values in the sequence. Indeed, for a length-1 sequence it would be equally valid 
to use `(last some-var)` since first=last if there is only one item in the list.

To clarify that we are simply _unwrapping_ a single value from
the sequence, we may use the function `only`:

[source,clojure]
---- 
(only seq-arg)
  Ensures that a sequence is of length=1, and returns the only value present.
  Throws an exception if the length of the sequence is not one.  Note that, 
  for a length-1 sequence S, (first S), (last S) and (only S) are equivalent.
----

=== The Truth Is Not Ambiguous

Clojure marries the worlds of Java and Lisp. Unfortunately, these two worlds have different ideas of
truth, so Clojure accepts both `false` and `nil` as _false_. Sometimes, however, you want to coerce
logical values into literal _true_ or _false_ values, so we provide a simple way to do that:

[source,clojure]
----
(truthy? arg)
  Returns true if arg is logical true (neither nil nor false);
  otherwise returns false.

(falsey? arg)
  Returns true if arg is logical false (either nil or false);
  otherwise returns false. Equivalent to (not (truthy? arg)).
----

Since `truthy?` and `falsey?` are functions (instead of special forms or
macros), we can use them as an argument to `filter` or any other place that a
higher-order-function is required:

[source,clojure]
----
(def data [true :a 'my-symbol 1 "hello" \x false nil])
(filter truthy? data)
;=> [true :a my-symbol 1 "hello" \x]
(filter falsey? data)
;=> [false nil]

(is (every? truthy? [true :a 'my-symbol 1 "hello" \x] ))
(is (every? falsey? [false nil] ))

(let [count-if (comp count keep-if) ]
  (let [num-true    (count-if truthy? data)   ; <= better than (count-if boolean data)
        num-false   (count-if falsey? data) ] ; <= better than (count-if not     data)
    (is (and  (= 6 num-true)
              (= 2 num-false) )))))
----

=== Identifying Sequences

In some situations, a function may need to verify that an argument is _seqable_, that is, that it
may be interpreted as a sequence of values.  Clojure doesn't have a built-in function for this, but
we can copy one from the old `clojure.contrib.core/seqable`:

[source,clojure]
----
(is (seqable?   "abc"))
(is (seqable?   {1 2 3 4} ))
(is (seqable?  #{1 2 3} ))
(is (seqable?  '(1 2 3) ))
(is (seqable?   [1 2 3] ))
(is (seqable?   (byte-array [1 2] )))

(is (not (seqable?  1 )))
(is (not (seqable? \a )))
----

=== REPL Driven Testing

Developing at the REPL is productive & cool, but it can be a pain to reload source files
modified in an external editor.  This is especially so when simultaneously editing both
the core program and the corresponding test code.  The function `test-all` will reload
both a namespace and its corresponding test namespace from file, then invoke the corresponding
test namespace:

[source,clojure]
----
(test-all & ns-names)
  Convenience fn to reload a namespace & the corresponding test namespace from disk and
  execute tests in the REPL.  Assumes canonical project test file organization with
  parallel src/... & test/tst/... directories, where a 'tst.' prefix is added to all src
  namespaces to generate the cooresponding test namespace.  Example:

    (test-all 'tupelo.core 'tupelo.csv)

  This will reload tupelo.core, tst.tupelo.core, tupelo.csv, tst.tupelo.csv and
  then execute clojure.test/run-tests on both of the test namespaces.
----

== Requirements
 - Clojure 1.7.0
 - Java 1.8

== To Do
 - types
 - schema (& schema-datomic)
 - re-work csv
 - kill y64?
 - Update all NS docstrings

== License

Copyright © 2015 Alan Thompson. 

Distributed under the Eclipse Public License, the same as Clojure.

