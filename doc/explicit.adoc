= tupelo.explicit

== Explicit Language for Clojure

=== Overview

Have you ever found yourself uncertain about the result of calling a function in
Clojure? Unfortunately, dynamic languages like Clojure sometimes give you *too
much* flexibility.  They "helpfully" return `nil` when a sought-for object isn't
present, or perhaps convert one type into another in an effor to avoid problems.
The problem is, that _sometimes_ they do one thing, then _sometimes_ do something
else.  Which behavior you get depends on the context.  Since you can't always
tell the execution context when reading the code, you are left with
unpredictable (at least to you) code behavior.  Of course, since the code may
be run in a different context at some point in the future, what once worked
predictably can later become unpredictable (i.e. a bug).  

=== tupelo.explicit - Explicit Language for Clojure

Clojure tries to be flexible and return reasonable default value (usually `nil`) when
something goes wrong (for example, looking up a non-existent key in a map).  The functions in 
`tupelo.explicit` disable this behavior and instead implement a "fail-fast" philosophy.


